<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>數據轉三圍曲線分析器</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        body {
            font-family: 'Microsoft JhengHei', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            margin: 0;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .charts-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        .chart-container {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        .controls {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
        }
        .btn {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 16px;
            cursor: pointer;
            margin: 10px;
        }
        .btn:hover {
            transform: translateY(-2px);
        }
        .results {
            background: #f1f3f4;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 14px;
            white-space: pre-wrap;
        }
        .benchmark-line {
            border-left: 3px solid #ff6b6b;
            padding-left: 15px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>📊 數據轉三圍曲線分析器</h1>
            <p>檢查 SLG→POW, BA→HIT, OBP→EYE 的轉換曲線單調性</p>
        </div>

        <div class="controls">
            <button class="btn" onclick="generateAllCurves()">生成所有轉換曲線</button>
            <button class="btn" onclick="testProblematicCases()">測試問題案例</button>
            <button class="btn" onclick="testBenchmarks()">測試基準點</button>
        </div>

        <div class="charts-grid">
            <div class="chart-container">
                <h3 style="text-align: center; color: #333;">SLG → POW 轉換</h3>
                <canvas id="slgToPowChart" width="400" height="300"></canvas>
            </div>
            <div class="chart-container">
                <h3 style="text-align: center; color: #333;">BA → HIT 轉換</h3>
                <canvas id="baToHitChart" width="400" height="300"></canvas>
            </div>
            <div class="chart-container">
                <h3 style="text-align: center; color: #333;">OBP → EYE 轉換</h3>
                <canvas id="obpToEyeChart" width="400" height="300"></canvas>
            </div>
        </div>

        <div id="analysisResults" class="results" style="display: none;"></div>
    </div>

    <script>
        // 常數定義
        const LEAGUE_BENCHMARKS = {
            'xBA': {'pr1': 0.200, 'pr50': 0.250, 'pr99': 0.330},
            'xSLG': {'pr1': 0.310, 'pr50': 0.400, 'pr99': 0.640},
            'xwOBA': {'pr1': 0.260, 'pr50': 0.320, 'pr99': 0.430}
        };
        const ATTRIBUTE_MAPPING_POINTS = {'pr1': 40, 'pr50': 70, 'pr99': 99};
        
        // 數據轉三圍的計算函數（從你的代碼複製）
        function getAttributeScoreExtreme(metricVal, pr1Benchmark, pr50Benchmark, pr99Benchmark, statType) {
            const pr1_map = ATTRIBUTE_MAPPING_POINTS['pr1'];
            const pr50_map = ATTRIBUTE_MAPPING_POINTS['pr50'];
            const pr99_map = ATTRIBUTE_MAPPING_POINTS['pr99'];
            const delta_50_1 = pr50_map - pr1_map;
            const delta_99_50 = pr99_map - pr50_map;
            
            let score = 0;
            
            const isExtremeValue = (
                (statType === 'BA' && metricVal >= 0.95) ||
                (statType === 'SLG' && metricVal >= 3.0) ||
                (statType === 'OBA' && metricVal >= 0.95)
            );
            
            if (isExtremeValue) {
                if (statType === 'BA' && metricVal >= 1.0) return 500;
                if (statType === 'SLG' && metricVal >= 3.5) return 500;
                if (statType === 'OBA' && metricVal >= 1.0) return 500;
                
                if (statType === 'BA') {
                    return 200 + (metricVal - 0.95) / 0.05 * 300;
                }
                if (statType === 'SLG') {
                    return 200 + (metricVal - 3.0) / 0.5 * 300;
                }
                if (statType === 'OBA') {
                    return 200 + (metricVal - 0.95) / 0.05 * 300;
                }
            }
            
            if (metricVal <= pr1Benchmark) {
                score = pr1_map;
            } else if (metricVal <= pr50Benchmark) {
                score = pr1_map + delta_50_1 * (metricVal - pr1Benchmark) / (pr50Benchmark - pr1Benchmark);
            } else if (metricVal <= pr99Benchmark) {
                score = pr50_map + delta_99_50 * (metricVal - pr50Benchmark) / (pr99Benchmark - pr50Benchmark);
            } else {
                const slope_pr50_pr99 = delta_99_50 / (pr99Benchmark - pr50Benchmark);
                const basicExtension = pr99_map + slope_pr50_pr99 * (metricVal - pr99Benchmark);
                const overPr99Factor = (metricVal - pr99Benchmark) / (pr99Benchmark - pr50Benchmark);
                let extraBonus = 0;
                
                if (statType === 'SLG') {
                    extraBonus = Math.min(overPr99Factor * 80, 300);
                } else if (statType === 'BA') {
                    extraBonus = Math.min(overPr99Factor * 60, 250);
                } else if (statType === 'OBA') {
                    extraBonus = Math.min(overPr99Factor * 60, 250);
                }
                
                score = basicExtension + extraBonus;
            }
            
            return Math.max(0, Math.min(500, score));
        }

        let charts = {};

        function generateSingleCurve(statType, canvasId, title) {
            let benchmarks, dataRange, step;
            
            if (statType === 'SLG') {
                benchmarks = LEAGUE_BENCHMARKS['xSLG'];
                dataRange = [0.000, 1.000];
                step = 0.010;
            } else if (statType === 'BA') {
                benchmarks = LEAGUE_BENCHMARKS['xBA'];
                dataRange = [0.000, 0.500];
                step = 0.005;
            } else { // OBA
                benchmarks = LEAGUE_BENCHMARKS['xwOBA'];
                dataRange = [0.000, 0.600];
                step = 0.005;
            }
            
            const dataPoints = [];
            const labels = [];
            let monotonicity = true;
            let lastAttribute = -1;
            
            for (let val = dataRange[0]; val <= dataRange[1]; val += step) {
                const attribute = getAttributeScoreExtreme(val, benchmarks.pr1, benchmarks.pr50, benchmarks.pr99, statType);
                dataPoints.push(attribute);
                labels.push(val.toFixed(3));
                
                if (attribute < lastAttribute) {
                    monotonicity = false;
                }
                lastAttribute = attribute;
            }
            
            const ctx = document.getElementById(canvasId).getContext('2d');
            
            if (charts[canvasId]) {
                charts[canvasId].destroy();
            }
            
            charts[canvasId] = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: `${title}`,
                        data: dataPoints,
                        borderColor: statType === 'SLG' ? '#ff6b6b' : statType === 'BA' ? '#4ecdc4' : '#ffa726',
                        backgroundColor: statType === 'SLG' ? 'rgba(255, 107, 107, 0.1)' : statType === 'BA' ? 'rgba(78, 205, 196, 0.1)' : 'rgba(255, 167, 38, 0.1)',
                        borderWidth: 3,
                        fill: true,
                        tension: 0.1,
                        pointRadius: 0,
                        pointHoverRadius: 5
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: title,
                            font: { size: 14 }
                        },
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: `${statType} 數值`
                            },
                            ticks: {
                                maxTicksLimit: 10
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: '屬性值'
                            },
                            min: 0,
                            max: 200
                        }
                    },
                    elements: {
                        point: {
                            hoverRadius: 8
                        }
                    }
                }
            });
            
            return { monotonicity, min: Math.min(...dataPoints), max: Math.max(...dataPoints) };
        }

        function generateAllCurves() {
            const slgResult = generateSingleCurve('SLG', 'slgToPowChart', 'SLG → POW');
            const baResult = generateSingleCurve('BA', 'baToHitChart', 'BA → HIT');
            const obpResult = generateSingleCurve('OBA', 'obpToEyeChart', 'OBP → EYE');
            
            const resultsDiv = document.getElementById('analysisResults');
            resultsDiv.style.display = 'block';
            resultsDiv.innerHTML = `
🔍 數據轉三圍曲線分析:

📈 SLG → POW 轉換:
   單調性: ${slgResult.monotonicity ? '✅ 通過' : '❌ 失敗'}
   屬性範圍: ${slgResult.min} - ${slgResult.max}
   
📈 BA → HIT 轉換:
   單調性: ${baResult.monotonicity ? '✅ 通過' : '❌ 失敗'}
   屬性範圍: ${baResult.min} - ${baResult.max}
   
📈 OBP → EYE 轉換:
   單調性: ${obpResult.monotonicity ? '✅ 通過' : '❌ 失敗'}
   屬性範圍: ${obpResult.min} - ${obpResult.max}

🎯 基準點檢查:
   SLG 0.310 (PR1) → POW: ${getAttributeScoreExtreme(0.310, LEAGUE_BENCHMARKS['xSLG']['pr1'], LEAGUE_BENCHMARKS['xSLG']['pr50'], LEAGUE_BENCHMARKS['xSLG']['pr99'], 'SLG').toFixed(1)} (期望: 40)
   SLG 0.400 (PR50) → POW: ${getAttributeScoreExtreme(0.400, LEAGUE_BENCHMARKS['xSLG']['pr1'], LEAGUE_BENCHMARKS['xSLG']['pr50'], LEAGUE_BENCHMARKS['xSLG']['pr99'], 'SLG').toFixed(1)} (期望: 70)
   SLG 0.640 (PR99) → POW: ${getAttributeScoreExtreme(0.640, LEAGUE_BENCHMARKS['xSLG']['pr1'], LEAGUE_BENCHMARKS['xSLG']['pr50'], LEAGUE_BENCHMARKS['xSLG']['pr99'], 'SLG').toFixed(1)} (期望: 99)
   
   BA 0.200 (PR1) → HIT: ${getAttributeScoreExtreme(0.200, LEAGUE_BENCHMARKS['xBA']['pr1'], LEAGUE_BENCHMARKS['xBA']['pr50'], LEAGUE_BENCHMARKS['xBA']['pr99'], 'BA').toFixed(1)} (期望: 40)
   BA 0.250 (PR50) → HIT: ${getAttributeScoreExtreme(0.250, LEAGUE_BENCHMARKS['xBA']['pr1'], LEAGUE_BENCHMARKS['xBA']['pr50'], LEAGUE_BENCHMARKS['xBA']['pr99'], 'BA').toFixed(1)} (期望: 70)
   BA 0.330 (PR99) → HIT: ${getAttributeScoreExtreme(0.330, LEAGUE_BENCHMARKS['xBA']['pr1'], LEAGUE_BENCHMARKS['xBA']['pr50'], LEAGUE_BENCHMARKS['xBA']['pr99'], 'BA').toFixed(1)} (期望: 99)
   
   OBP 0.260 (PR1) → EYE: ${getAttributeScoreExtreme(0.260, LEAGUE_BENCHMARKS['xwOBA']['pr1'], LEAGUE_BENCHMARKS['xwOBA']['pr50'], LEAGUE_BENCHMARKS['xwOBA']['pr99'], 'OBA').toFixed(1)} (期望: 40)
   OBP 0.320 (PR50) → EYE: ${getAttributeScoreExtreme(0.320, LEAGUE_BENCHMARKS['xwOBA']['pr1'], LEAGUE_BENCHMARKS['xwOBA']['pr50'], LEAGUE_BENCHMARKS['xwOBA']['pr99'], 'OBA').toFixed(1)} (期望: 70)
   OBP 0.430 (PR99) → EYE: ${getAttributeScoreExtreme(0.430, LEAGUE_BENCHMARKS['xwOBA']['pr1'], LEAGUE_BENCHMARKS['xwOBA']['pr50'], LEAGUE_BENCHMARKS['xwOBA']['pr99'], 'OBA').toFixed(1)} (期望: 99)
            `;
        }

        function testProblematicCases() {
            // 測試你截圖中的問題案例
            const testCases = [
                {name: '問題案例1', xBA: 0.2, xSLG: 0.3, xwOBA: 0.25},
                {name: '問題案例2', xBA: 0.01, xSLG: 0.01, xwOBA: 0.01},
                {name: '極低數據', xBA: 0.100, xSLG: 0.200, xwOBA: 0.200},
                {name: '正常數據', xBA: 0.280, xSLG: 0.450, xwOBA: 0.350},
                {name: '優秀數據', xBA: 0.320, xSLG: 0.600, xwOBA: 0.420}
            ];
            
            let results = '🧪 問題案例測試:\n\n';
            
            testCases.forEach(testCase => {
                const powScore = getAttributeScoreExtreme(testCase.xSLG, LEAGUE_BENCHMARKS['xSLG']['pr1'], LEAGUE_BENCHMARKS['xSLG']['pr50'], LEAGUE_BENCHMARKS['xSLG']['pr99'], 'SLG');
                const hitScore = getAttributeScoreExtreme(testCase.xBA, LEAGUE_BENCHMARKS['xBA']['pr1'], LEAGUE_BENCHMARKS['xBA']['pr50'], LEAGUE_BENCHMARKS['xBA']['pr99'], 'BA');
                const eyeScore = getAttributeScoreExtreme(testCase.xwOBA, LEAGUE_BENCHMARKS['xwOBA']['pr1'], LEAGUE_BENCHMARKS['xwOBA']['pr50'], LEAGUE_BENCHMARKS['xwOBA']['pr99'], 'OBA');
                
                results += `${testCase.name}:\n`;
                results += `   輸入: BA=${testCase.xBA}, SLG=${testCase.xSLG}, OBP=${testCase.xwOBA}\n`;
                results += `   輸出: POW=${powScore.toFixed(1)}, HIT=${hitScore.toFixed(1)}, EYE=${eyeScore.toFixed(1)}\n`;
                results += `   平均: ${((powScore + hitScore + eyeScore) / 3).toFixed(1)}\n\n`;
            });
            
            const resultsDiv = document.getElementById('analysisResults');
            resultsDiv.style.display = 'block';
            resultsDiv.innerHTML = results;
        }

        function testBenchmarks() {
            const benchmarkTests = [
                // PR1 基準點
                {xBA: 0.200, xSLG: 0.310, xwOBA: 0.260, expected: 'PR1 (40,40,40)'},
                // PR50 基準點  
                {xBA: 0.250, xSLG: 0.400, xwOBA: 0.320, expected: 'PR50 (70,70,70)'},
                // PR99 基準點
                {xBA: 0.330, xSLG: 0.640, xwOBA: 0.430, expected: 'PR99 (99,99,99)'}
            ];
            
            let results = '🎯 基準點精確度測試:\n\n';
            
            benchmarkTests.forEach(test => {
                const powScore = getAttributeScoreExtreme(test.xSLG, LEAGUE_BENCHMARKS['xSLG']['pr1'], LEAGUE_BENCHMARKS['xSLG']['pr50'], LEAGUE_BENCHMARKS['xSLG']['pr99'], 'SLG');
                const hitScore = getAttributeScoreExtreme(test.xBA, LEAGUE_BENCHMARKS['xBA']['pr1'], LEAGUE_BENCHMARKS['xBA']['pr50'], LEAGUE_BENCHMARKS['xBA']['pr99'], 'BA');
                const eyeScore = getAttributeScoreExtreme(test.xwOBA, LEAGUE_BENCHMARKS['xwOBA']['pr1'], LEAGUE_BENCHMARKS['xwOBA']['pr50'], LEAGUE_BENCHMARKS['xwOBA']['pr99'], 'OBA');
                
                results += `${test.expected}:\n`;
                results += `   輸入: BA=${test.xBA}, SLG=${test.xSLG}, OBP=${test.xwOBA}\n`;
                results += `   實際: POW=${powScore.toFixed(1)}, HIT=${hitScore.toFixed(1)}, EYE=${eyeScore.toFixed(1)}\n`;
                
                // 檢查精確度
                const powError = Math.abs(powScore - (test.expected.includes('40') ? 40 : test.expected.includes('70') ? 70 : 99));
                const hitError = Math.abs(hitScore - (test.expected.includes('40') ? 40 : test.expected.includes('70') ? 70 : 99));
                const eyeError = Math.abs(eyeScore - (test.expected.includes('40') ? 40 : test.expected.includes('70') ? 70 : 99));
                
                results += `   誤差: POW±${powError.toFixed(1)}, HIT±${hitError.toFixed(1)}, EYE±${eyeError.toFixed(1)}\n`;
                results += `   ${(powError < 0.1 && hitError < 0.1 && eyeError < 0.1) ? '✅ 精確' : '❌ 偏差'}\n\n`;
            });
            
            const resultsDiv = document.getElementById('analysisResults');
            resultsDiv.style.display = 'block';
            resultsDiv.innerHTML = results;
        }

        // 頁面載入時自動生成圖表
        window.onload = function() {
            generateAllCurves();
        };
    </script>
</body>
</html>