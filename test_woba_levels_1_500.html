<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complete wOBA Level Mapping (1-500)</title>
    <script src="src/js/constants.js"></script>
    <script src="src/js/probability_model.js"></script>
    <script src="src/js/simulation_engine.js"></script>
    <style>
        body { font-family: monospace; margin: 20px; font-size: 12px; }
        table { border-collapse: collapse; margin: 10px 0; }
        th, td { border: 1px solid #ccc; padding: 4px; text-align: center; font-size: 11px; }
        th { background-color: #f5f5f5; }
        .anchor { background-color: #ffffcc; font-weight: bold; }
        .edge { background-color: #ffcccc; font-weight: bold; }
        .section { margin: 20px 0; border: 1px solid #ddd; padding: 15px; }
        .data-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; }
    </style>
</head>
<body>
    <h1>Complete wOBA Level Mapping (1-500)</h1>
    <p>完整的等級 wOBA 對照表，邊緣設定為 10</p>
    
    <div id="summary"></div>
    <div id="detailed-table"></div>

    <script>
        // 使用真正的 probability_model 進行模擬
        function simulateLevel(level) {
            // 使用 level 作為 HIT/POW/EYE 的均衡值
            const HIT = level;
            const POW = level;  
            const EYE = level;
            
            // 調用真正的模擬引擎
            const results = simulateMultipleAtBats(EYE, HIT, POW, 600);
            
            console.log(`Level ${level} 原始模擬結果:`, results);
            
            // 計算統計數據
            const pa = 600;
            const bb = results.BB || 0;
            const hits = (results['1B'] || 0) + (results['2B'] || 0) + (results.HR || 0);
            const ab = pa - bb;
            const singles = results['1B'] || 0;
            const doubles = results['2B'] || 0;
            const triples = 0; // 當前模擬引擎沒有3B
            const homers = results.HR || 0;
            
            // 基礎統計計算
            const ba = ab > 0 ? hits / ab : 0;
            const obp = pa > 0 ? (hits + bb) / pa : 0;
            const totalBases = singles + doubles * 2 + triples * 3 + homers * 4;
            const slg = ab > 0 ? totalBases / ab : 0;
            
            // 計算 wOBA (使用模擬結果中的原始數據)
            const wobaWeights = { BB: 0.692, '1B': 0.879, '2B': 1.242, '3B': 1.568, HR: 2.081 };
            const woba = pa > 0 ? (bb * wobaWeights.BB + singles * wobaWeights['1B'] + 
                                  doubles * wobaWeights['2B'] + triples * wobaWeights['3B'] + 
                                  homers * wobaWeights.HR) / pa : 0;
            
            return {
                AB: ab,
                BB: bb,
                H: hits,
                '1B': singles,
                '2B': doubles,
                '3B': triples,
                HR_count: homers,
                BA: ba,
                OBP: obp,
                SLG: slg,
                wOBA: woba
            };
        }
        
        // 簡化版 - 直接使用模擬結果中的wOBA
        function calculateWOBA(stats) {
            // 模擬引擎已經計算好wOBA了，直接返回
            return stats.wOBA || 0;
        }
        
        function generateCompleteLevelMapping() {
            const results = [];
            const summaryResults = [];
            
            console.log('🎯 生成完整等級 wOBA 對照表 (1-500)');
            
            // 生成每10級的完整數據 + 關鍵錨點
            const allLevelsData = [];
            const testLevels = [];
            
            // 每10級數據：10, 20, 30, ... 500
            for (let level = 10; level <= 500; level += 10) {
                testLevels.push(level);
            }
            
            // 添加特殊關鍵點
            const keyAnchors = [1, 5]; // 極低值點
            keyAnchors.forEach(anchor => {
                if (!testLevels.includes(anchor)) {
                    testLevels.push(anchor);
                }
            });
            
            // 排序
            testLevels.sort((a, b) => a - b);
            
            for (let level of testLevels) {
                try {
                    console.log(`正在模擬等級 ${level}...`);
                    // 使用與Node.js版本相同的簡化模擬
                    const stats = simulateLevel(level);
                    
                    // 檢查模擬結果
                    console.log(`Level ${level} 模擬結果:`, stats);
                    
                    const woba = calculateWOBA(stats);
                    const ops = (stats.OBP || 0) + (stats.SLG || 0);
                    
                    allLevelsData.push({
                        level: level,
                        woba: woba,
                        ops: ops,
                        ba: stats.BA || 0,
                        obp: stats.OBP || 0,
                        slg: stats.SLG || 0,
                        hr: Math.round(stats.HR_count || 0),
                        bb: Math.round(stats.BB || 0)
                    });
                    
                    console.log(`LVL ${level}: wOBA=${woba.toFixed(3)}, OPS=${ops.toFixed(3)}`);
                    
                } catch (error) {
                    console.error(`錯誤：等級 ${level} 模擬失敗`, error);
                    // 提供備用數據
                    allLevelsData.push({
                        level: level,
                        woba: 0.000,
                        ops: 0.000,
                        ba: 0.000,
                        obp: 0.000,
                        slg: 0.000,
                        hr: 0,
                        bb: 0
                    });
                }
            }
            
            // 關鍵等級摘要
            summaryResults.push('<div class="section"><h2>關鍵等級摘要</h2>');
            summaryResults.push('<table><tr><th>等級</th><th>分類</th><th>wOBA</th><th>OPS</th><th>BA</th><th>OBP</th><th>SLG</th><th>HR</th><th>BB</th></tr>');
            
            // 關鍵等級定義
            const keyLevels = [1, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 200, 250, 300, 400, 500];
            
            keyLevels.forEach(level => {
                const data = allLevelsData.find(d => d.level === level) || 
                            allLevelsData.find(d => Math.abs(d.level - level) <= 2);
                            
                if (!data) return;
                
                let category = '';
                let cssClass = '';
                if (level === 1) { category = '最低'; cssClass = 'edge'; }
                else if (level === 10) { category = '邊緣'; cssClass = 'edge'; }
                else if (level === 40) { category = '小聯盟'; }
                else if (level === 70) { category = '聯盟平均'; cssClass = 'anchor'; }
                else if (level === 100) { category = '精英'; cssClass = 'anchor'; }
                else if (level === 120) { category = '名人堂'; cssClass = 'anchor'; }
                else if (level === 150) { category = '歷史傳奇'; cssClass = 'anchor'; }
                else if (level >= 200) { category = '神話級'; }
                
                summaryResults.push(
                    `<tr class="${cssClass}"><td>${data.level}</td><td>${category}</td>` +
                    `<td>${data.woba.toFixed(3)}</td><td>${data.ops.toFixed(3)}</td>` +
                    `<td>${data.ba.toFixed(3)}</td><td>${data.obp.toFixed(3)}</td>` +
                    `<td>${data.slg.toFixed(3)}</td><td>${data.hr}</td><td>${data.bb}</td></tr>`
                );
            });
            summaryResults.push('</table></div>');
            
            // wOBA 增長趨勢分析
            summaryResults.push('<div class="section"><h2>wOBA 增長趨勢分析</h2>');
            
            const growthAnalysis = [];
            for (let i = 1; i < allLevelsData.length; i++) {
                const prev = allLevelsData[i-1];
                const curr = allLevelsData[i];
                const growth = curr.woba - prev.woba;
                const levelDiff = curr.level - prev.level;
                const growthRate = growth / levelDiff;
                
                if (curr.level <= 200 && curr.level % 25 === 0) {
                    growthAnalysis.push({
                        level: curr.level,
                        woba: curr.woba,
                        growth: growth,
                        growthRate: growthRate
                    });
                }
            }
            
            summaryResults.push('<table><tr><th>等級</th><th>wOBA</th><th>從前級增長</th><th>每級增長率</th><th>趋势</th></tr>');
            growthAnalysis.forEach((item, index) => {
                let trend = '';
                if (index > 0) {
                    const prevRate = growthAnalysis[index-1].growthRate;
                    if (item.growthRate > prevRate * 1.1) trend = '加速 ↗';
                    else if (item.growthRate < prevRate * 0.9) trend = '減速 ↘';
                    else trend = '穩定 →';
                }
                
                summaryResults.push(
                    `<tr><td>${item.level}</td><td>${item.woba.toFixed(3)}</td>` +
                    `<td>+${item.growth.toFixed(4)}</td><td>+${(item.growthRate*1000).toFixed(2)}/k</td>` +
                    `<td>${trend}</td></tr>`
                );
            });
            summaryResults.push('</table></div>');
            
            // 完整每10級數據表
            results.push('<div class="section"><h2>完整每10級數據表 (1-500)</h2>');
            results.push('<table><tr><th>等級</th><th>wOBA</th><th>OPS</th><th>BA</th><th>OBP</th><th>SLG</th><th>HR</th><th>BB</th><th>分類</th></tr>');
            
            // 按等級排序
            const sortedData = allLevelsData.sort((a, b) => a.level - b.level);
            
            sortedData.forEach(data => {
                // 分類標籤
                let category = '';
                let cssClass = '';
                if (data.level === 1) { category = '最低'; cssClass = 'edge'; }
                else if (data.level === 10) { category = '邊緣'; cssClass = 'edge'; }
                else if (data.level >= 10 && data.level < 40) { category = '業餘'; }
                else if (data.level >= 40 && data.level < 70) { category = '小聯盟'; }
                else if (data.level === 70) { category = '聯盟平均'; cssClass = 'anchor'; }
                else if (data.level > 70 && data.level < 100) { category = '優質'; }
                else if (data.level === 100) { category = '精英'; cssClass = 'anchor'; }
                else if (data.level > 100 && data.level < 120) { category = '全明星'; }
                else if (data.level === 120) { category = '名人堂'; cssClass = 'anchor'; }
                else if (data.level > 120 && data.level < 150) { category = '超級巨星'; }
                else if (data.level === 150) { category = '歷史傳奇'; cssClass = 'anchor'; }
                else if (data.level > 150) { category = '神話級'; }
                
                results.push(
                    `<tr class="${cssClass}"><td>${data.level}</td>` +
                    `<td>${data.woba.toFixed(3)}</td><td>${data.ops.toFixed(3)}</td>` +
                    `<td>${data.ba.toFixed(3)}</td><td>${data.obp.toFixed(3)}</td>` +
                    `<td>${data.slg.toFixed(3)}</td><td>${data.hr}</td><td>${data.bb}</td>` +
                    `<td>${category}</td></tr>`
                );
            });
            
            results.push('</table></div>');
            
            // 特殊里程碑
            summaryResults.push('<div class="section"><h2>wOBA 里程碑</h2>');
            const milestones = [
                {woba: 0.300, desc: '替補球員門檻'},
                {woba: 0.320, desc: 'MLB 聯盟平均'},
                {woba: 0.350, desc: '優質先發'},
                {woba: 0.400, desc: '全明星級'},
                {woba: 0.450, desc: '超級巨星'},
                {woba: 0.500, desc: '歷史級賽季'},
                {woba: 0.550, desc: '神話級表現'},
                {woba: 0.600, desc: '理論極限'}
            ];
            
            summaryResults.push('<table><tr><th>wOBA</th><th>描述</th><th>對應等級</th><th>實際OPS</th></tr>');
            
            milestones.forEach(milestone => {
                const closestData = allLevelsData.reduce((prev, curr) => 
                    Math.abs(curr.woba - milestone.woba) < Math.abs(prev.woba - milestone.woba) ? curr : prev
                );
                
                summaryResults.push(
                    `<tr><td>${milestone.woba.toFixed(3)}</td><td>${milestone.desc}</td>` +
                    `<td>~${closestData.level}</td><td>${closestData.ops.toFixed(3)}</td></tr>`
                );
            });
            summaryResults.push('</table></div>');
            
            // 創建 wOBA 線形圖
            results.push('<div class="section"><h2>等級 vs wOBA 線形圖</h2>');
            results.push('<canvas id="wobaChart" width="800" height="400" style="border: 1px solid #ddd;"></canvas>');
            results.push('</div>');
            
            // 輸出結果
            document.getElementById('summary').innerHTML = summaryResults.join('');
            document.getElementById('detailed-table').innerHTML = results.join('');
            
            // 生成圖表
            drawWobaChart(allLevelsData);
            
            console.log('✅ 完整等級 wOBA 對照表生成完成');
            
            // 輸出給 JavaScript 使用的數據
            console.log('📊 生成 wOBA 映射數組:');
            const mappingData = allLevelsData.map(d => `{level: ${d.level}, woba: ${d.woba.toFixed(4)}}`);
            console.log('const wobaLevelMapping = [');
            console.log(mappingData.slice(0, 20).join(',\n'));
            console.log('  // ... 更多數據');
            console.log('];');
            
            return allLevelsData;
        }
        
        // 繪製 wOBA 線形圖
        function drawWobaChart(data) {
            const canvas = document.getElementById('wobaChart');
            const ctx = canvas.getContext('2d');
            
            // 清空畫布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 設定邊距
            const margin = { top: 40, right: 40, bottom: 60, left: 80 };
            const chartWidth = canvas.width - margin.left - margin.right;
            const chartHeight = canvas.height - margin.top - margin.bottom;
            
            // 數據範圍
            const maxLevel = Math.max(...data.map(d => d.level));
            const minLevel = Math.min(...data.map(d => d.level));
            const maxWoba = Math.max(...data.map(d => d.woba));
            const minWoba = Math.min(...data.map(d => d.woba));
            
            // 座標轉換函數
            const xScale = (level) => margin.left + (level - minLevel) / (maxLevel - minLevel) * chartWidth;
            const yScale = (woba) => margin.top + (1 - (woba - minWoba) / (maxWoba - minWoba)) * chartHeight;
            
            // 繪製背景網格
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 0.5;
            
            // 垂直網格線
            for (let level = 0; level <= 500; level += 50) {
                if (level >= minLevel && level <= maxLevel) {
                    const x = xScale(level);
                    ctx.beginPath();
                    ctx.moveTo(x, margin.top);
                    ctx.lineTo(x, margin.top + chartHeight);
                    ctx.stroke();
                }
            }
            
            // 水平網格線
            for (let woba = 0; woba <= 1.0; woba += 0.1) {
                if (woba >= minWoba && woba <= maxWoba) {
                    const y = yScale(woba);
                    ctx.beginPath();
                    ctx.moveTo(margin.left, y);
                    ctx.lineTo(margin.left + chartWidth, y);
                    ctx.stroke();
                }
            }
            
            // 繪製軸線
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            
            // X軸
            ctx.beginPath();
            ctx.moveTo(margin.left, margin.top + chartHeight);
            ctx.lineTo(margin.left + chartWidth, margin.top + chartHeight);
            ctx.stroke();
            
            // Y軸
            ctx.beginPath();
            ctx.moveTo(margin.left, margin.top);
            ctx.lineTo(margin.left, margin.top + chartHeight);
            ctx.stroke();
            
            // 繪製數據線
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            data.forEach((point, index) => {
                const x = xScale(point.level);
                const y = yScale(point.woba);
                
                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            ctx.stroke();
            
            // 繪製數據點
            ctx.fillStyle = '#ff6b6b';
            data.forEach(point => {
                const x = xScale(point.level);
                const y = yScale(point.woba);
                
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, 2 * Math.PI);
                ctx.fill();
                
                // 標註關鍵錨點
                if ([10, 70, 100, 120, 150].includes(point.level)) {
                    ctx.fillStyle = '#333';
                    ctx.font = '12px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${point.level}: ${point.woba.toFixed(3)}`, x, y - 15);
                    ctx.fillStyle = '#ff6b6b';
                }
            });
            
            // 添加軸標籤
            ctx.fillStyle = '#333';
            ctx.font = '14px monospace';
            ctx.textAlign = 'center';
            
            // X軸標籤
            ctx.fillText('等級 (Level)', margin.left + chartWidth / 2, canvas.height - 20);
            
            // Y軸標籤
            ctx.save();
            ctx.translate(20, margin.top + chartHeight / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('wOBA', 0, 0);
            ctx.restore();
            
            // 添加刻度標籤
            ctx.font = '12px monospace';
            ctx.textAlign = 'center';
            
            // X軸刻度
            for (let level = 0; level <= 500; level += 100) {
                if (level >= minLevel && level <= maxLevel) {
                    const x = xScale(level);
                    ctx.fillText(level.toString(), x, margin.top + chartHeight + 20);
                }
            }
            
            // Y軸刻度
            ctx.textAlign = 'right';
            for (let woba = 0; woba <= 1.0; woba += 0.1) {
                if (woba >= minWoba && woba <= maxWoba) {
                    const y = yScale(woba);
                    ctx.fillText(woba.toFixed(1), margin.left - 10, y + 4);
                }
            }
            
            // 圖表標題
            ctx.font = '16px monospace';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#333';
            ctx.fillText('等級 vs wOBA 關係圖', margin.left + chartWidth / 2, 25);
        }
        
        // 當頁面載入時執行
        window.addEventListener('load', generateCompleteLevelMapping);
    </script>
</body>
</html>