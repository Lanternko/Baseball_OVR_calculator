<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complete wOBA Level Mapping (1-500)</title>
    <script src="src/js/constants.js"></script>
    <script src="src/js/probability_model.js"></script>
    <script src="src/js/simulation_engine.js"></script>
    <style>
        body { font-family: monospace; margin: 20px; font-size: 12px; }
        table { border-collapse: collapse; margin: 10px 0; }
        th, td { border: 1px solid #ccc; padding: 4px; text-align: center; font-size: 11px; }
        th { background-color: #f5f5f5; }
        .anchor { background-color: #ffffcc; font-weight: bold; }
        .edge { background-color: #ffcccc; font-weight: bold; }
        .section { margin: 20px 0; border: 1px solid #ddd; padding: 15px; }
        .data-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; }
    </style>
</head>
<body>
    <h1>Complete wOBA Level Mapping (1-500)</h1>
    <p>å®Œæ•´çš„ç­‰ç´š wOBA å°ç…§è¡¨ï¼Œé‚Šç·£è¨­å®šç‚º 10</p>
    
    <div id="summary"></div>
    <div id="detailed-table"></div>

    <script>
        // ä½¿ç”¨çœŸæ­£çš„ probability_model é€²è¡Œæ¨¡æ“¬
        function simulateLevel(level) {
            // ä½¿ç”¨ level ä½œç‚º HIT/POW/EYE çš„å‡è¡¡å€¼
            const HIT = level;
            const POW = level;  
            const EYE = level;
            
            // èª¿ç”¨çœŸæ­£çš„æ¨¡æ“¬å¼•æ“
            const results = simulateMultipleAtBats(EYE, HIT, POW, 600);
            
            console.log(`Level ${level} åŸå§‹æ¨¡æ“¬çµæœ:`, results);
            
            // è¨ˆç®—çµ±è¨ˆæ•¸æ“š
            const pa = 600;
            const bb = results.BB || 0;
            const hits = (results['1B'] || 0) + (results['2B'] || 0) + (results.HR || 0);
            const ab = pa - bb;
            const singles = results['1B'] || 0;
            const doubles = results['2B'] || 0;
            const triples = 0; // ç•¶å‰æ¨¡æ“¬å¼•æ“æ²’æœ‰3B
            const homers = results.HR || 0;
            
            // åŸºç¤çµ±è¨ˆè¨ˆç®—
            const ba = ab > 0 ? hits / ab : 0;
            const obp = pa > 0 ? (hits + bb) / pa : 0;
            const totalBases = singles + doubles * 2 + triples * 3 + homers * 4;
            const slg = ab > 0 ? totalBases / ab : 0;
            
            // è¨ˆç®— wOBA (ä½¿ç”¨æ¨¡æ“¬çµæœä¸­çš„åŸå§‹æ•¸æ“š)
            const wobaWeights = { BB: 0.692, '1B': 0.879, '2B': 1.242, '3B': 1.568, HR: 2.081 };
            const woba = pa > 0 ? (bb * wobaWeights.BB + singles * wobaWeights['1B'] + 
                                  doubles * wobaWeights['2B'] + triples * wobaWeights['3B'] + 
                                  homers * wobaWeights.HR) / pa : 0;
            
            return {
                AB: ab,
                BB: bb,
                H: hits,
                '1B': singles,
                '2B': doubles,
                '3B': triples,
                HR_count: homers,
                BA: ba,
                OBP: obp,
                SLG: slg,
                wOBA: woba
            };
        }
        
        // ç°¡åŒ–ç‰ˆ - ç›´æ¥ä½¿ç”¨æ¨¡æ“¬çµæœä¸­çš„wOBA
        function calculateWOBA(stats) {
            // æ¨¡æ“¬å¼•æ“å·²ç¶“è¨ˆç®—å¥½wOBAäº†ï¼Œç›´æ¥è¿”å›
            return stats.wOBA || 0;
        }
        
        function generateCompleteLevelMapping() {
            const results = [];
            const summaryResults = [];
            
            console.log('ğŸ¯ ç”Ÿæˆå®Œæ•´ç­‰ç´š wOBA å°ç…§è¡¨ (1-500)');
            
            // ç”Ÿæˆæ¯10ç´šçš„å®Œæ•´æ•¸æ“š + é—œéµéŒ¨é»
            const allLevelsData = [];
            const testLevels = [];
            
            // æ¯10ç´šæ•¸æ“šï¼š10, 20, 30, ... 500
            for (let level = 10; level <= 500; level += 10) {
                testLevels.push(level);
            }
            
            // æ·»åŠ ç‰¹æ®Šé—œéµé»
            const keyAnchors = [1, 5]; // æ¥µä½å€¼é»
            keyAnchors.forEach(anchor => {
                if (!testLevels.includes(anchor)) {
                    testLevels.push(anchor);
                }
            });
            
            // æ’åº
            testLevels.sort((a, b) => a - b);
            
            for (let level of testLevels) {
                try {
                    console.log(`æ­£åœ¨æ¨¡æ“¬ç­‰ç´š ${level}...`);
                    // ä½¿ç”¨èˆ‡Node.jsç‰ˆæœ¬ç›¸åŒçš„ç°¡åŒ–æ¨¡æ“¬
                    const stats = simulateLevel(level);
                    
                    // æª¢æŸ¥æ¨¡æ“¬çµæœ
                    console.log(`Level ${level} æ¨¡æ“¬çµæœ:`, stats);
                    
                    const woba = calculateWOBA(stats);
                    const ops = (stats.OBP || 0) + (stats.SLG || 0);
                    
                    allLevelsData.push({
                        level: level,
                        woba: woba,
                        ops: ops,
                        ba: stats.BA || 0,
                        obp: stats.OBP || 0,
                        slg: stats.SLG || 0,
                        hr: Math.round(stats.HR_count || 0),
                        bb: Math.round(stats.BB || 0)
                    });
                    
                    console.log(`LVL ${level}: wOBA=${woba.toFixed(3)}, OPS=${ops.toFixed(3)}`);
                    
                } catch (error) {
                    console.error(`éŒ¯èª¤ï¼šç­‰ç´š ${level} æ¨¡æ“¬å¤±æ•—`, error);
                    // æä¾›å‚™ç”¨æ•¸æ“š
                    allLevelsData.push({
                        level: level,
                        woba: 0.000,
                        ops: 0.000,
                        ba: 0.000,
                        obp: 0.000,
                        slg: 0.000,
                        hr: 0,
                        bb: 0
                    });
                }
            }
            
            // é—œéµç­‰ç´šæ‘˜è¦
            summaryResults.push('<div class="section"><h2>é—œéµç­‰ç´šæ‘˜è¦</h2>');
            summaryResults.push('<table><tr><th>ç­‰ç´š</th><th>åˆ†é¡</th><th>wOBA</th><th>OPS</th><th>BA</th><th>OBP</th><th>SLG</th><th>HR</th><th>BB</th></tr>');
            
            // é—œéµç­‰ç´šå®šç¾©
            const keyLevels = [1, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 200, 250, 300, 400, 500];
            
            keyLevels.forEach(level => {
                const data = allLevelsData.find(d => d.level === level) || 
                            allLevelsData.find(d => Math.abs(d.level - level) <= 2);
                            
                if (!data) return;
                
                let category = '';
                let cssClass = '';
                if (level === 1) { category = 'æœ€ä½'; cssClass = 'edge'; }
                else if (level === 10) { category = 'é‚Šç·£'; cssClass = 'edge'; }
                else if (level === 40) { category = 'å°è¯ç›Ÿ'; }
                else if (level === 70) { category = 'è¯ç›Ÿå¹³å‡'; cssClass = 'anchor'; }
                else if (level === 100) { category = 'ç²¾è‹±'; cssClass = 'anchor'; }
                else if (level === 120) { category = 'åäººå ‚'; cssClass = 'anchor'; }
                else if (level === 150) { category = 'æ­·å²å‚³å¥‡'; cssClass = 'anchor'; }
                else if (level >= 200) { category = 'ç¥è©±ç´š'; }
                
                summaryResults.push(
                    `<tr class="${cssClass}"><td>${data.level}</td><td>${category}</td>` +
                    `<td>${data.woba.toFixed(3)}</td><td>${data.ops.toFixed(3)}</td>` +
                    `<td>${data.ba.toFixed(3)}</td><td>${data.obp.toFixed(3)}</td>` +
                    `<td>${data.slg.toFixed(3)}</td><td>${data.hr}</td><td>${data.bb}</td></tr>`
                );
            });
            summaryResults.push('</table></div>');
            
            // wOBA å¢é•·è¶¨å‹¢åˆ†æ
            summaryResults.push('<div class="section"><h2>wOBA å¢é•·è¶¨å‹¢åˆ†æ</h2>');
            
            const growthAnalysis = [];
            for (let i = 1; i < allLevelsData.length; i++) {
                const prev = allLevelsData[i-1];
                const curr = allLevelsData[i];
                const growth = curr.woba - prev.woba;
                const levelDiff = curr.level - prev.level;
                const growthRate = growth / levelDiff;
                
                if (curr.level <= 200 && curr.level % 25 === 0) {
                    growthAnalysis.push({
                        level: curr.level,
                        woba: curr.woba,
                        growth: growth,
                        growthRate: growthRate
                    });
                }
            }
            
            summaryResults.push('<table><tr><th>ç­‰ç´š</th><th>wOBA</th><th>å¾å‰ç´šå¢é•·</th><th>æ¯ç´šå¢é•·ç‡</th><th>è¶‹åŠ¿</th></tr>');
            growthAnalysis.forEach((item, index) => {
                let trend = '';
                if (index > 0) {
                    const prevRate = growthAnalysis[index-1].growthRate;
                    if (item.growthRate > prevRate * 1.1) trend = 'åŠ é€Ÿ â†—';
                    else if (item.growthRate < prevRate * 0.9) trend = 'æ¸›é€Ÿ â†˜';
                    else trend = 'ç©©å®š â†’';
                }
                
                summaryResults.push(
                    `<tr><td>${item.level}</td><td>${item.woba.toFixed(3)}</td>` +
                    `<td>+${item.growth.toFixed(4)}</td><td>+${(item.growthRate*1000).toFixed(2)}/k</td>` +
                    `<td>${trend}</td></tr>`
                );
            });
            summaryResults.push('</table></div>');
            
            // å®Œæ•´æ¯10ç´šæ•¸æ“šè¡¨
            results.push('<div class="section"><h2>å®Œæ•´æ¯10ç´šæ•¸æ“šè¡¨ (1-500)</h2>');
            results.push('<table><tr><th>ç­‰ç´š</th><th>wOBA</th><th>OPS</th><th>BA</th><th>OBP</th><th>SLG</th><th>HR</th><th>BB</th><th>åˆ†é¡</th></tr>');
            
            // æŒ‰ç­‰ç´šæ’åº
            const sortedData = allLevelsData.sort((a, b) => a.level - b.level);
            
            sortedData.forEach(data => {
                // åˆ†é¡æ¨™ç±¤
                let category = '';
                let cssClass = '';
                if (data.level === 1) { category = 'æœ€ä½'; cssClass = 'edge'; }
                else if (data.level === 10) { category = 'é‚Šç·£'; cssClass = 'edge'; }
                else if (data.level >= 10 && data.level < 40) { category = 'æ¥­é¤˜'; }
                else if (data.level >= 40 && data.level < 70) { category = 'å°è¯ç›Ÿ'; }
                else if (data.level === 70) { category = 'è¯ç›Ÿå¹³å‡'; cssClass = 'anchor'; }
                else if (data.level > 70 && data.level < 100) { category = 'å„ªè³ª'; }
                else if (data.level === 100) { category = 'ç²¾è‹±'; cssClass = 'anchor'; }
                else if (data.level > 100 && data.level < 120) { category = 'å…¨æ˜æ˜Ÿ'; }
                else if (data.level === 120) { category = 'åäººå ‚'; cssClass = 'anchor'; }
                else if (data.level > 120 && data.level < 150) { category = 'è¶…ç´šå·¨æ˜Ÿ'; }
                else if (data.level === 150) { category = 'æ­·å²å‚³å¥‡'; cssClass = 'anchor'; }
                else if (data.level > 150) { category = 'ç¥è©±ç´š'; }
                
                results.push(
                    `<tr class="${cssClass}"><td>${data.level}</td>` +
                    `<td>${data.woba.toFixed(3)}</td><td>${data.ops.toFixed(3)}</td>` +
                    `<td>${data.ba.toFixed(3)}</td><td>${data.obp.toFixed(3)}</td>` +
                    `<td>${data.slg.toFixed(3)}</td><td>${data.hr}</td><td>${data.bb}</td>` +
                    `<td>${category}</td></tr>`
                );
            });
            
            results.push('</table></div>');
            
            // ç‰¹æ®Šé‡Œç¨‹ç¢‘
            summaryResults.push('<div class="section"><h2>wOBA é‡Œç¨‹ç¢‘</h2>');
            const milestones = [
                {woba: 0.300, desc: 'æ›¿è£œçƒå“¡é–€æª»'},
                {woba: 0.320, desc: 'MLB è¯ç›Ÿå¹³å‡'},
                {woba: 0.350, desc: 'å„ªè³ªå…ˆç™¼'},
                {woba: 0.400, desc: 'å…¨æ˜æ˜Ÿç´š'},
                {woba: 0.450, desc: 'è¶…ç´šå·¨æ˜Ÿ'},
                {woba: 0.500, desc: 'æ­·å²ç´šè³½å­£'},
                {woba: 0.550, desc: 'ç¥è©±ç´šè¡¨ç¾'},
                {woba: 0.600, desc: 'ç†è«–æ¥µé™'}
            ];
            
            summaryResults.push('<table><tr><th>wOBA</th><th>æè¿°</th><th>å°æ‡‰ç­‰ç´š</th><th>å¯¦éš›OPS</th></tr>');
            
            milestones.forEach(milestone => {
                const closestData = allLevelsData.reduce((prev, curr) => 
                    Math.abs(curr.woba - milestone.woba) < Math.abs(prev.woba - milestone.woba) ? curr : prev
                );
                
                summaryResults.push(
                    `<tr><td>${milestone.woba.toFixed(3)}</td><td>${milestone.desc}</td>` +
                    `<td>~${closestData.level}</td><td>${closestData.ops.toFixed(3)}</td></tr>`
                );
            });
            summaryResults.push('</table></div>');
            
            // å‰µå»º wOBA ç·šå½¢åœ–
            results.push('<div class="section"><h2>ç­‰ç´š vs wOBA ç·šå½¢åœ–</h2>');
            results.push('<canvas id="wobaChart" width="800" height="400" style="border: 1px solid #ddd;"></canvas>');
            results.push('</div>');
            
            // è¼¸å‡ºçµæœ
            document.getElementById('summary').innerHTML = summaryResults.join('');
            document.getElementById('detailed-table').innerHTML = results.join('');
            
            // ç”Ÿæˆåœ–è¡¨
            drawWobaChart(allLevelsData);
            
            console.log('âœ… å®Œæ•´ç­‰ç´š wOBA å°ç…§è¡¨ç”Ÿæˆå®Œæˆ');
            
            // è¼¸å‡ºçµ¦ JavaScript ä½¿ç”¨çš„æ•¸æ“š
            console.log('ğŸ“Š ç”Ÿæˆ wOBA æ˜ å°„æ•¸çµ„:');
            const mappingData = allLevelsData.map(d => `{level: ${d.level}, woba: ${d.woba.toFixed(4)}}`);
            console.log('const wobaLevelMapping = [');
            console.log(mappingData.slice(0, 20).join(',\n'));
            console.log('  // ... æ›´å¤šæ•¸æ“š');
            console.log('];');
            
            return allLevelsData;
        }
        
        // ç¹ªè£½ wOBA ç·šå½¢åœ–
        function drawWobaChart(data) {
            const canvas = document.getElementById('wobaChart');
            const ctx = canvas.getContext('2d');
            
            // æ¸…ç©ºç•«å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // è¨­å®šé‚Šè·
            const margin = { top: 40, right: 40, bottom: 60, left: 80 };
            const chartWidth = canvas.width - margin.left - margin.right;
            const chartHeight = canvas.height - margin.top - margin.bottom;
            
            // æ•¸æ“šç¯„åœ
            const maxLevel = Math.max(...data.map(d => d.level));
            const minLevel = Math.min(...data.map(d => d.level));
            const maxWoba = Math.max(...data.map(d => d.woba));
            const minWoba = Math.min(...data.map(d => d.woba));
            
            // åº§æ¨™è½‰æ›å‡½æ•¸
            const xScale = (level) => margin.left + (level - minLevel) / (maxLevel - minLevel) * chartWidth;
            const yScale = (woba) => margin.top + (1 - (woba - minWoba) / (maxWoba - minWoba)) * chartHeight;
            
            // ç¹ªè£½èƒŒæ™¯ç¶²æ ¼
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 0.5;
            
            // å‚ç›´ç¶²æ ¼ç·š
            for (let level = 0; level <= 500; level += 50) {
                if (level >= minLevel && level <= maxLevel) {
                    const x = xScale(level);
                    ctx.beginPath();
                    ctx.moveTo(x, margin.top);
                    ctx.lineTo(x, margin.top + chartHeight);
                    ctx.stroke();
                }
            }
            
            // æ°´å¹³ç¶²æ ¼ç·š
            for (let woba = 0; woba <= 1.0; woba += 0.1) {
                if (woba >= minWoba && woba <= maxWoba) {
                    const y = yScale(woba);
                    ctx.beginPath();
                    ctx.moveTo(margin.left, y);
                    ctx.lineTo(margin.left + chartWidth, y);
                    ctx.stroke();
                }
            }
            
            // ç¹ªè£½è»¸ç·š
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            
            // Xè»¸
            ctx.beginPath();
            ctx.moveTo(margin.left, margin.top + chartHeight);
            ctx.lineTo(margin.left + chartWidth, margin.top + chartHeight);
            ctx.stroke();
            
            // Yè»¸
            ctx.beginPath();
            ctx.moveTo(margin.left, margin.top);
            ctx.lineTo(margin.left, margin.top + chartHeight);
            ctx.stroke();
            
            // ç¹ªè£½æ•¸æ“šç·š
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            data.forEach((point, index) => {
                const x = xScale(point.level);
                const y = yScale(point.woba);
                
                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            ctx.stroke();
            
            // ç¹ªè£½æ•¸æ“šé»
            ctx.fillStyle = '#ff6b6b';
            data.forEach(point => {
                const x = xScale(point.level);
                const y = yScale(point.woba);
                
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, 2 * Math.PI);
                ctx.fill();
                
                // æ¨™è¨»é—œéµéŒ¨é»
                if ([10, 70, 100, 120, 150].includes(point.level)) {
                    ctx.fillStyle = '#333';
                    ctx.font = '12px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${point.level}: ${point.woba.toFixed(3)}`, x, y - 15);
                    ctx.fillStyle = '#ff6b6b';
                }
            });
            
            // æ·»åŠ è»¸æ¨™ç±¤
            ctx.fillStyle = '#333';
            ctx.font = '14px monospace';
            ctx.textAlign = 'center';
            
            // Xè»¸æ¨™ç±¤
            ctx.fillText('ç­‰ç´š (Level)', margin.left + chartWidth / 2, canvas.height - 20);
            
            // Yè»¸æ¨™ç±¤
            ctx.save();
            ctx.translate(20, margin.top + chartHeight / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('wOBA', 0, 0);
            ctx.restore();
            
            // æ·»åŠ åˆ»åº¦æ¨™ç±¤
            ctx.font = '12px monospace';
            ctx.textAlign = 'center';
            
            // Xè»¸åˆ»åº¦
            for (let level = 0; level <= 500; level += 100) {
                if (level >= minLevel && level <= maxLevel) {
                    const x = xScale(level);
                    ctx.fillText(level.toString(), x, margin.top + chartHeight + 20);
                }
            }
            
            // Yè»¸åˆ»åº¦
            ctx.textAlign = 'right';
            for (let woba = 0; woba <= 1.0; woba += 0.1) {
                if (woba >= minWoba && woba <= maxWoba) {
                    const y = yScale(woba);
                    ctx.fillText(woba.toFixed(1), margin.left - 10, y + 4);
                }
            }
            
            // åœ–è¡¨æ¨™é¡Œ
            ctx.font = '16px monospace';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#333';
            ctx.fillText('ç­‰ç´š vs wOBA é—œä¿‚åœ–', margin.left + chartWidth / 2, 25);
        }
        
        // ç•¶é é¢è¼‰å…¥æ™‚åŸ·è¡Œ
        window.addEventListener('load', generateCompleteLevelMapping);
    </script>
</body>
</html>