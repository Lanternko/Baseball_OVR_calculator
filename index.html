<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>棒球能力值雙向轉換計算器</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Microsoft JhengHei', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px;
            padding: 40px;
        }
        
        .calculator-section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease;
        }
        
        .calculator-section:hover {
            transform: translateY(-5px);
        }
        
        .section-title {
            font-size: 1.5em;
            color: #333;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #4ecdc4;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #555;
        }
        
        .input-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-size: 16px;
            transition: border-color 0.3s ease;
        }
        
        .input-group input:focus {
            outline: none;
            border-color: #4ecdc4;
            box-shadow: 0 0 10px rgba(78, 205, 196, 0.3);
        }
        
        .button {
            width: 100%;
            padding: 15px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            margin-top: 10px;
        }
        
        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }
        
        .results {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            border-left: 5px solid #4ecdc4;
        }
        
        .result-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid #eee;
        }
        
        .result-item:last-child {
            border-bottom: none;
        }
        
        .result-label {
            font-weight: bold;
            color: #555;
        }
        
        .result-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #333;
        }
        
        .ovr-display {
            text-align: center;
            padding: 20px;
            background: linear-gradient(45deg, #ffeaa7, #fab1a0);
            border-radius: 15px;
            margin-top: 20px;
        }
        
        .ovr-number {
            font-size: 3em;
            font-weight: bold;
            color: #2d3436;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .ovr-label {
            font-size: 1.2em;
            color: #636e72;
            margin-top: 10px;
        }
        
        .ovr-breakdown {
            margin-top: 15px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 8px;
            font-size: 0.9em;
            line-height: 1.4;
        }
        
        .icon {
            font-size: 1.2em;
        }
        
        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
                gap: 20px;
                padding: 20px;
            }
            
            .header h1 {
                font-size: 2em;
            }
        }
        
        .help-text {
            font-size: 0.9em;
            color: #666;
            margin-top: 5px;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>⚾ 棒球能力值雙向轉換計算器</h1>
            <p>基於 POW/HIT/EYE 三圍系統的棒球數據預測工具</p>
        </div>
        
        <div class="main-content">
            <!-- 數據轉三圍 -->
            <div class="calculator-section">
                <h2 class="section-title">
                    <span class="icon">📊</span>
                    數據 → 三圍 + OVR
                </h2>
                
                <div class="input-group">
                    <label for="xBA">預期打擊率 (xBA)</label>
                    <input type="number" id="xBA" step="0.001" placeholder="例如: 0.280" min="0" max="1">
                    <div class="help-text">通常在 0.200 - 0.350 之間</div>
                </div>
                
                <div class="input-group">
                    <label for="xSLG">預期長打率 (xSLG)</label>
                    <input type="number" id="xSLG" step="0.001" placeholder="例如: 0.450" min="0" max="4">
                    <div class="help-text">通常在 0.300 - 0.700 之間</div>
                </div>
                
                <div class="input-group">
                    <label for="xwOBA">預期加權上壘率 (xwOBA)</label>
                    <input type="number" id="xwOBA" step="0.001" placeholder="例如: 0.350" min="0" max="1">
                    <div class="help-text">通常在 0.250 - 0.450 之間</div>
                </div>
                
                <button class="button" onclick="calculateAttributes()">
                    計算三圍 + OVR
                </button>
                
                <div id="attributeResults" class="results" style="display: none;">
                    <div class="result-item">
                        <span class="result-label">💪 POW (Power)</span>
                        <span class="result-value" id="powResult">-</span>
                    </div>
                    <div class="result-item">
                        <span class="result-label">🎯 HIT (Hit Tool)</span>
                        <span class="result-value" id="hitResult">-</span>
                    </div>
                    <div class="result-item">
                        <span class="result-label">👁️ EYE (Plate Discipline)</span>
                        <span class="result-value" id="eyeResult">-</span>
                    </div>
                    
                    <div class="ovr-display">
                        <div class="ovr-number" id="ovrFromStats">-</div>
                        <div class="ovr-label">Overall Rating (OVR)</div>
                        <div class="ovr-breakdown" id="ovrBreakdownStats"></div>
                    </div>
                </div>
            </div>
            
            <!-- 三圍轉數據 -->
            <div class="calculator-section">
                <h2 class="section-title">
                    <span class="icon">⚙️</span>
                    三圍 → 預測數據
                </h2>
                
                <div class="input-group">
                    <label for="inputPOW">POW (Power)</label>
                    <input type="number" id="inputPOW" placeholder="例如: 85" min="0" max="150">
                    <div class="help-text">建議範圍: 30-120</div>
                </div>
                
                <div class="input-group">
                    <label for="inputHIT">HIT (Hit Tool)</label>
                    <input type="number" id="inputHIT" placeholder="例如: 75" min="0" max="150">
                    <div class="help-text">建議範圍: 30-120</div>
                </div>
                
                <div class="input-group">
                    <label for="inputEYE">EYE (Plate Discipline)</label>
                    <input type="number" id="inputEYE" placeholder="例如: 80" min="0" max="150">
                    <div class="help-text">建議範圍: 30-120</div>
                </div>
                
                <div class="input-group">
                    <label for="inputPA">打席數 (PA)</label>
                    <input type="number" id="inputPA" placeholder="例如: 600" min="1" max="1000">
                    <div class="help-text">一個完整賽季通常 500-700 打席</div>
                </div>
                
                <button class="button" onclick="calculateStats()">
                    預測數據 + OVR
                </button>
                
                <div id="statsResults" class="results" style="display: none;">
                    <div class="result-item">
                        <span class="result-label">📈 打擊率 (BA)</span>
                        <span class="result-value" id="baResult">-</span>
                    </div>
                    <div class="result-item">
                        <span class="result-label">🏃 上壘率 (OBP)</span>
                        <span class="result-value" id="obpResult">-</span>
                    </div>
                    <div class="result-item">
                        <span class="result-label">💥 長打率 (SLG)</span>
                        <span class="result-value" id="slgResult">-</span>
                    </div>
                    <div class="result-item">
                        <span class="result-label">🔥 OPS</span>
                        <span class="result-value" id="opsResult">-</span>
                    </div>
                    <div class="result-item">
                        <span class="result-label">⚾ 全壘打</span>
                        <span class="result-value" id="hrResult">-</span>
                    </div>
                    <div class="result-item">
                        <span class="result-label">👁️ 保送率</span>
                        <span class="result-value" id="bbRateResult">-</span>
                    </div>
                    <div class="result-item">
                        <span class="result-label">🌪️ 三振率</span>
                        <span class="result-value" id="kRateResult">-</span>
                    </div>
                    
                    <div class="ovr-display">
                        <div class="ovr-number" id="ovrFromAttributes">-</div>
                        <div class="ovr-label">Overall Rating (OVR)</div>
                        <div class="ovr-breakdown" id="ovrBreakdownAttributes"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 常數定義
        const LEAGUE_BENCHMARKS = {
            'xBA': {'pr1': 0.200, 'pr50': 0.250, 'pr99': 0.330},
            'xSLG': {'pr1': 0.310, 'pr50': 0.400, 'pr99': 0.640},
            'xwOBA': {'pr1': 0.260, 'pr50': 0.320, 'pr99': 0.430}
        };
        
        const ATTRIBUTE_MAPPING_POINTS = {'pr1': 40, 'pr50': 70, 'pr99': 99};
        const SOFT_CAP_ATTRIBUTE_VALUE = 150.0;
        const ATTR_EFFECT_MIDPOINT = 70.0;
        
        const HR_S_CURVE_POW_ANCHORS = [
            [0, 0.0005], [30, 0.003], [40, 0.0067], [60, 0.020],
            [70, 0.0333], [85, 0.045], [99, 0.0580], [115, 0.072],
            [125, 0.080], [130, 0.0870], [140, 0.098], [150, 0.110]
        ];
        
        const BABIP_S_CURVE_HIT_ANCHORS = [
            [0, 0.215], [30, 0.245], [40, 0.270], [60, 0.295],
            [70, 0.305], [85, 0.330], [99, 0.350], [110, 0.365],
            [120, 0.375], [130, 0.385], [140, 0.395], [150, 0.405]
        ];
        
        const BB_S_CURVE_EYE_ANCHORS = [
            [0, 0.030], [30, 0.045], [40, 0.062], [60, 0.075],
            [70, 0.085], [85, 0.105], [99, 0.125], [115, 0.145],
            [130, 0.160], [140, 0.170], [150, 0.180]
        ];
        
        const K_EYE_EFFECTIVENESS_S_CURVE_ANCHORS = [
            [0, 0.8], [30, 0.5], [40, 0.3], [60, 0.1],
            [70, 0.0], [85, -0.20], [99, -0.40], [115, -0.55],
            [130, -0.70], [140, -0.75], [150, -0.80]
        ];
        
        const AVG_K_RATE_AT_MIDPOINT = 0.220;
        const MIN_K_RATE_CAP = 0.080;
        const MAX_K_RATE_CAP = 0.350;
        const K_RATE_HIT_WEIGHT = 0.50;
        const K_RATE_EYE_WEIGHT = 0.50;
        const K_HIT_EFFECT_MIDPOINT = 70.0;
        const K_HIT_EFFECT_SCALE = 55.0;
        
        const AVG_2B_PER_HIT_BIP_NOT_HR_AT_MIDPOINT = 0.31;
        const MIN_2B_PER_HIT_BIP_NOT_HR = 0.22;
        const MAX_2B_PER_HIT_BIP_NOT_HR = 0.42;
        const EXTRABASE_POW_EFFECT_MIDPOINT = 70.0;
        const EXTRABASE_POW_EFFECT_SCALE = 48.0;
        const EXTRABASE_HIT_EFFECT_MIDPOINT = 70.0;
        const EXTRABASE_HIT_EFFECT_SCALE = 48.0;
        const EXTRABASE_POW_WEIGHT = 0.50;
        const EXTRABASE_HIT_WEIGHT = 0.50;
        
        const LEAGUE_AVG_HBP_RATE = 0.010;
        const NUM_SIMULATIONS = 100; // 降低模擬次數提升效能

        // =============== 極端數據處理修補程式 ===============
        // 這個程式碼可以直接加入到您現有的 index.html 中，取代原有的 calculatePlayerGameAttributes 函數

        // 修改後的 calculatePlayerGameAttributes 函數，支援極端值處理
        function calculatePlayerGameAttributes(xBA, xSLG, xwOBA) {
            const pr1_map = ATTRIBUTE_MAPPING_POINTS['pr1'];
            const pr50_map = ATTRIBUTE_MAPPING_POINTS['pr50'];
            const pr99_map = ATTRIBUTE_MAPPING_POINTS['pr99'];
            const delta_50_1 = pr50_map - pr1_map;
            const delta_99_50 = pr99_map - pr50_map;
            
            // 🔥 改進的極端值處理函數
            function getAttributeScoreExtreme(metricVal, pr1Benchmark, pr50Benchmark, pr99Benchmark, statType) {
                let score = 0;
                
                // 理論極限值的特殊處理
                const isExtremeValue = (
                    (statType === 'BA' && metricVal >= 0.99) ||
                    (statType === 'SLG' && metricVal >= 3.8) ||
                    (statType === 'OBA' && metricVal >= 0.99)
                );
                
                if (isExtremeValue) {
                    // 理論極限值：BA=1, SLG=4, OBA=1 都映射到相同的極高屬性值
                    if (statType === 'BA' && metricVal >= 1.0) return 500;
                    if (statType === 'SLG' && metricVal >= 4.0) return 500;
                    if (statType === 'OBA' && metricVal >= 1.0) return 500;
                    
                    // 接近極限值的處理
                    if (statType === 'BA') {
                        return 300 + (metricVal - 0.99) / 0.01 * 200; // 0.99-1.0 映射到 300-500
                    }
                    if (statType === 'SLG') {
                        return 300 + (metricVal - 3.8) / 0.2 * 200; // 3.8-4.0 映射到 300-500
                    }
                    if (statType === 'OBA') {
                        return 300 + (metricVal - 0.99) / 0.01 * 200; // 0.99-1.0 映射到 300-500
                    }
                }
                
                // 正常範圍的處理
                if (metricVal <= pr1Benchmark) {
                    score = pr1_map;
                } else if (metricVal <= pr50Benchmark) {
                    score = pr1_map + delta_50_1 * (metricVal - pr1Benchmark) / (pr50Benchmark - pr1Benchmark);
                } else if (metricVal <= pr99Benchmark) {
                    score = pr50_map + delta_99_50 * (metricVal - pr50Benchmark) / (pr99Benchmark - pr50Benchmark);
                } else {
                    // 超出 pr99 但未到極限的線性擴展
                    const slope_pr50_pr99 = delta_99_50 / (pr99Benchmark - pr50Benchmark);
                    const basicExtension = pr99_map + slope_pr50_pr99 * (metricVal - pr99Benchmark);
                    
                    // 對於超高值給予額外加成
                    const overPr99Factor = (metricVal - pr99Benchmark) / (pr99Benchmark - pr50Benchmark);
                    const extraBonus = Math.min(overPr99Factor * 50, 200); // 最多額外+200
                    
                    score = basicExtension + extraBonus;
                }
                
                return Math.max(0, Math.min(500, score)); // 允許最高到500
            }
            
            const powScore = getAttributeScoreExtreme(xSLG, LEAGUE_BENCHMARKS['xSLG']['pr1'], LEAGUE_BENCHMARKS['xSLG']['pr50'], LEAGUE_BENCHMARKS['xSLG']['pr99'], 'SLG');
            const hitScore = getAttributeScoreExtreme(xBA, LEAGUE_BENCHMARKS['xBA']['pr1'], LEAGUE_BENCHMARKS['xBA']['pr50'], LEAGUE_BENCHMARKS['xBA']['pr99'], 'BA');
            const eyeScore = getAttributeScoreExtreme(xwOBA, LEAGUE_BENCHMARKS['xwOBA']['pr1'], LEAGUE_BENCHMARKS['xwOBA']['pr50'], LEAGUE_BENCHMARKS['xwOBA']['pr99'], 'OBA');
            
            return {
                POW: Math.round(powScore),
                HIT: Math.round(hitScore),
                EYE: Math.round(eyeScore)
            };
        }

        // 🔥 極端值修正：新的 S-Curve 錨點
        const BABIP_S_CURVE_HIT_ANCHORS_EXTREME = [
            [0, 0.215], [30, 0.245], [40, 0.270], [60, 0.295],
            [70, 0.305], [85, 0.330], [99, 0.350], [110, 0.380],
            [150, 0.450], [200, 0.550], [300, 0.750], [400, 0.900], [500, 0.980]
        ];

        const HR_S_CURVE_POW_ANCHORS_EXTREME = [
            [0, 0.0005], [30, 0.003], [40, 0.0067], [60, 0.020],
            [70, 0.0333], [85, 0.045], [99, 0.0580], [115, 0.072],
            [130, 0.0870], [140, 0.098], [150, 0.110],
            [200, 0.200], [300, 0.400], [400, 0.700], [500, 0.990]
        ];

        const BB_S_CURVE_EYE_ANCHORS_EXTREME = [
            [0, 0.030], [30, 0.045], [40, 0.062], [60, 0.075],
            [70, 0.085], [85, 0.105], [99, 0.125], [115, 0.145],
            [130, 0.160], [140, 0.170], [150, 0.180],
            [200, 0.300], [300, 0.500], [400, 0.750], [500, 0.950]
        ];

        // 修改後的概率計算函數，支援極端屬性值
        function calculateProbabilitiesExtreme(pow, hit, eye) {
            // 檢測是否為極端值（降低門檻到200）
            if (pow >= 200 || hit >= 200 || eye >= 200) {
                // 使用改進的極端值概率計算
                return calculateProbabilitiesExtremeCore(pow, hit, eye);
            }
            
            // 正常情況使用原有邏輯
            return getPAEventProbabilities(pow, hit, eye);
        }

        function calculateProbabilitiesExtremeCore(pow, hit, eye) {
            console.log(`🔥 極端值計算: POW=${pow}, HIT=${hit}, EYE=${eye}`);
            
            // 使用新的極端值 S-curves
            const pHR = interpolateSCurve(pow, HR_S_CURVE_POW_ANCHORS_EXTREME);
            const babip = interpolateSCurve(hit, BABIP_S_CURVE_HIT_ANCHORS_EXTREME);
            const pBB = interpolateSCurve(eye, BB_S_CURVE_EYE_ANCHORS_EXTREME);
            
            // 三振率計算（使用原有邏輯但加強極端值響應）
            const eyeKEffect = interpolateSCurve(eye, K_EYE_EFFECTIVENESS_S_CURVE_ANCHORS);
            const hitKEffect = scaleAttributeToEffectiveness(hit, K_HIT_EFFECT_MIDPOINT, 55.0, false);
            let kRate = getRateFromEffectiveness(
                AVG_K_RATE_AT_MIDPOINT, MIN_K_RATE_CAP, MAX_K_RATE_CAP,
                K_RATE_EYE_WEIGHT * eyeKEffect + K_RATE_HIT_WEIGHT * hitKEffect
            );
            
            // 極端值時大幅降低三振率
            if (hit >= 300 || eye >= 300) {
                kRate = Math.max(0.01, kRate * 0.2);
            }
            
            const pHBP = LEAGUE_AVG_HBP_RATE;
            
            console.log(`基礎概率: HR=${pHR.toFixed(3)}, BABIP=${babip.toFixed(3)}, BB=${pBB.toFixed(3)}, K=${kRate.toFixed(3)}`);
            
            // 檢查基礎概率是否合理
            const basicSum = pHR + pBB + pHBP + kRate;
            if (basicSum >= 1.0) {
                // 按比例縮放
                const scale = 0.95 / basicSum;
                const scaledHR = pHR * scale;
                const scaledBB = pBB * scale;
                const scaledK = kRate * scale;
                const remainingProb = 1.0 - scaledHR - scaledBB - pHBP - scaledK;
                
                return {
                    HR: scaledHR,
                    '2B': remainingProb * 0.3,
                    '1B': remainingProb * 0.7,
                    BB: scaledBB,
                    HBP: pHBP,
                    K: scaledK,
                    IPO: 0.001
                };
            }
            
            // 計算剩餘 BIP 事件
            const remainingBIP = 1.0 - pHR - pBB - pHBP - kRate;
            const pHitFromBIP = remainingBIP * babip;
            const pIPO = remainingBIP * (1.0 - babip);
            
            // 分配一二壘安打
            const extrabaseEffect = (pow + hit) / 1000; // 簡化的長打效果
            const p2BRatio = Math.min(0.8, 0.3 + extrabaseEffect);
            const p2B = pHitFromBIP * p2BRatio;
            const p1B = pHitFromBIP * (1 - p2BRatio);
            
            const result = {
                HR: pHR,
                '2B': p2B,
                '1B': p1B,
                BB: pBB,
                HBP: pHBP,
                K: kRate,
                IPO: pIPO
            };
            
            console.log(`最終結果:`, result);
            const totalProb = Object.values(result).reduce((a,b) => a+b, 0);
            console.log(`概率總和: ${totalProb.toFixed(4)}`);
            
            return result;
        }

        // 修改模擬函數支援極端值檢測
        function simulatePlayerStats(pow, hit, eye, numSeasons = 100, paPerSeason = 600) {
            // 檢測是否為極端值
            const isExtremeCase = pow >= 300 || hit >= 300 || eye >= 300;
            
            if (isExtremeCase) {
                console.log(`🔥 檢測到極端屬性值: POW=${pow}, HIT=${hit}, EYE=${eye}`);
            }
            
            // 使用改進的概率計算
            const probs = isExtremeCase ? 
                calculateProbabilitiesExtremeCore(pow, hit, eye) : 
                calculateProbabilities(pow, hit, eye);
            
            let totalStats = {
                HR: 0, '2B': 0, '1B': 0, BB: 0, HBP: 0, K: 0, IPO: 0,
                H: 0, AB: 0, PA: 0, OUT: 0
            };
            
            for (let season = 0; season < numSeasons; season++) {
                const seasonResult = simulateSeason(paPerSeason, probs);
                Object.keys(totalStats).forEach(key => {
                    totalStats[key] += seasonResult[key] || 0;
                });
            }
            
            // 計算平均數據
            const avgStats = calculateSimStats({
                HR: totalStats.HR / numSeasons,
                '2B': totalStats['2B'] / numSeasons,
                '1B': totalStats['1B'] / numSeasons,
                BB: totalStats.BB / numSeasons,
                HBP: totalStats.HBP / numSeasons,
                K: totalStats.K / numSeasons,
                IPO: totalStats.IPO / numSeasons,
                H: totalStats.H / numSeasons,
                AB: totalStats.AB / numSeasons,
                PA: totalStats.PA / numSeasons
            });
            
            if (isExtremeCase) {
                console.log(`🎯 極端值模擬結果: BA=${avgStats.BA.toFixed(3)}, SLG=${avgStats.SLG.toFixed(3)}, OBP=${avgStats.OBP.toFixed(3)}`);
            }
            
            return avgStats;
        }

        // 測試極端值的輔助函數
        function testExtremeValueHandling() {
            console.log("🧪 開始極端值處理測試...");
            
            // 測試理論極限
            const extremeAttribs = calculatePlayerGameAttributes(1.0, 4.0, 1.0);
            console.log("理論極限轉換結果:", extremeAttribs);
            
            // 測試反向模擬
            const extremeStats = simulatePlayerStats(extremeAttribs.POW, extremeAttribs.HIT, extremeAttribs.EYE, 50, 600);
            console.log("極限三圍模擬結果:", {
                BA: extremeStats.BA.toFixed(3),
                SLG: extremeStats.SLG.toFixed(3),
                OBP: extremeStats.OBP.toFixed(3),
                HR: extremeStats.HR_count
            });
            
            // 檢查是否達到理論極限
            const baError = Math.abs(extremeStats.BA - 1.0);
            const slgError = Math.abs(extremeStats.SLG - 4.0);
            const obpError = Math.abs(extremeStats.OBP - 1.0);
            
            console.log("誤差分析:", {
                BA_error: baError.toFixed(3),
                SLG_error: slgError.toFixed(3),
                OBP_error: obpError.toFixed(3),
                status: (baError < 0.1 && slgError < 0.5 && obpError < 0.1) ? "✅ 極限值處理成功" : "❌ 需要進一步調整"
            });
        }

        // 在頁面載入後自動測試（可選）
        // window.addEventListener('load', testExtremeValueHandling);

        // 在頁面載入後自動測試（可選）
        // window.addEventListener('load', testExtremeValueHandling);
        function interpolateSCurve(value, anchors) {
            if (!anchors || !anchors.length) return 0.0;
            const cappedValue = Math.min(value, SOFT_CAP_ATTRIBUTE_VALUE * 1.1);
            if (cappedValue <= anchors[0][0]) return anchors[0][1];
            if (cappedValue >= anchors[anchors.length - 1][0]) return anchors[anchors.length - 1][1];
            for (let i = 0; i < anchors.length - 1; i++) {
                const [x1, y1] = anchors[i];
                const [x2, y2] = anchors[i + 1];
                if (x1 <= cappedValue && cappedValue < x2) {
                    return (x2 - x1) ? y1 + (y2 - y1) * (cappedValue - x1) / (x2 - x1) : y1;
                }
            }
            return anchors[anchors.length - 1][1];
        }
        
        function scaleAttributeToEffectiveness(attributeValue, midpoint, scale, effectIsPositive = true) {
            if (scale === 0) return 0.0;
            const normalizedValue = (attributeValue - midpoint) / scale;
            const tanhVal = Math.tanh(normalizedValue);
            return effectIsPositive ? tanhVal : -tanhVal;
        }
        
        function getRateFromEffectiveness(baseRateAtMidpoint, minRate, maxRate, effectivenessFactor) {
            return effectivenessFactor >= 0 ? baseRateAtMidpoint + effectivenessFactor * (maxRate - baseRateAtMidpoint) :
                baseRateAtMidpoint + effectivenessFactor * (baseRateAtMidpoint - minRate);
        }
        
        function calculateHRRateFromPowSCurve(POW) { return interpolateSCurve(POW, HR_S_CURVE_POW_ANCHORS); }
        function calculateBABIPFromHitSCurve(HIT) { return Math.max(0.190, Math.min(0.450, interpolateSCurve(HIT, BABIP_S_CURVE_HIT_ANCHORS))); }
        function calculateBBRateFromEyeSCurve(EYE) { return Math.max(0.020, Math.min(0.250, interpolateSCurve(EYE, BB_S_CURVE_EYE_ANCHORS))); }
        function calculateKRateCombined(EYE, HIT) {
            const eyeKEffectiveness = interpolateSCurve(EYE, K_EYE_EFFECTIVENESS_S_CURVE_ANCHORS);
            const hitKEffectiveness = scaleAttributeToEffectiveness(HIT, K_HIT_EFFECT_MIDPOINT, K_HIT_EFFECT_SCALE, false);
            const combinedKEffectiveness = K_RATE_EYE_WEIGHT * eyeKEffectiveness + K_RATE_HIT_WEIGHT * hitKEffectiveness;
            return Math.max(MIN_K_RATE_CAP, Math.min(MAX_K_RATE_CAP, getRateFromEffectiveness(AVG_K_RATE_AT_MIDPOINT, MIN_K_RATE_CAP, MAX_K_RATE_CAP, combinedKEffectiveness)));
        }
        
        function getPAEventProbabilities(POW, HIT, EYE, playerHBPRate = LEAGUE_AVG_HBP_RATE) {
            const pK = calculateKRateCombined(EYE, HIT);
            const pBB = calculateBBRateFromEyeSCurve(EYE);
            const pHBP = Math.max(0.0, Math.min(0.05, playerHBPRate));
            let pHR = calculateHRRateFromPowSCurve(POW);
            const eyeEffHRMod = scaleAttributeToEffectiveness(EYE, 70.0, 40.0, true);
            const eyeModifier = 1.0 + (eyeEffHRMod * 0.12);
            const hitEffHRMod = scaleAttributeToEffectiveness(HIT, 70.0, 40.0, true);
            const hitModifier = 1.0 + (hitEffHRMod * 0.18);
            pHR = Math.max(0.0, Math.min(pHR * eyeModifier * hitModifier, 0.20));
            const probSumNonBIPPlusHR = pK + pBB + pHBP + pHR;
            let p1B, p2B, pIPO;
            if (probSumNonBIPPlusHR >= 1.0) {
                const scaleDown = 1.0 / probSumNonBIPPlusHR;
                pHR = Math.max(0, 1.0 - (pK * scaleDown + pBB * scaleDown + pHBP * scaleDown));
                p1B = p2B = pIPO = 0.0;
            } else {
                const pBIPForOtherOutcomes = 1.0 - probSumNonBIPPlusHR;
                const pHitGivenBIPRemaining = calculateBABIPFromHitSCurve(HIT);
                const pTotalHitsOnRemainingBIP = pBIPForOtherOutcomes * pHitGivenBIPRemaining;
                pIPO = Math.max(0, pBIPForOtherOutcomes * (1.0 - pHitGivenBIPRemaining));
                if (pTotalHitsOnRemainingBIP > 0) {
                    const powEffXBH = scaleAttributeToEffectiveness(POW, EXTRABASE_POW_EFFECT_MIDPOINT, EXTRABASE_POW_EFFECT_SCALE, true);
                    const hitEffXBH = scaleAttributeToEffectiveness(HIT, EXTRABASE_HIT_EFFECT_MIDPOINT, EXTRABASE_HIT_EFFECT_SCALE, true);
                    const combinedEffXBH = EXTRABASE_POW_WEIGHT * powEffXBH + EXTRABASE_HIT_WEIGHT * hitEffXBH;
                    const p2BGivenHitBIPNotHR = getRateFromEffectiveness(AVG_2B_PER_HIT_BIP_NOT_HR_AT_MIDPOINT, MIN_2B_PER_HIT_BIP_NOT_HR, MAX_2B_PER_HIT_BIP_NOT_HR, combinedEffXBH);
                    p2B = Math.max(0, pTotalHitsOnRemainingBIP * p2BGivenHitBIPNotHR);
                    p1B = Math.max(0, pTotalHitsOnRemainingBIP * (1.0 - p2BGivenHitBIPNotHR));
                } else {
                    p1B = p2B = 0.0;
                }
            }
            return {HR: pHR, '2B': p2B, '1B': p1B, BB: pBB, HBP: pHBP, K: pK, IPO: pIPO};
        }
        
        function simulateSeason(numPA, probabilities) {
            const outcomes = {HR: 0, '2B': 0, '1B': 0, BB: 0, HBP: 0, K: 0, IPO: 0, H: 0, AB: 0, PA: 0, OUT: 0};
            const eventOrder = ['HR', '2B', '1B', 'BB', 'HBP', 'K', 'IPO'];
            for (let i = 0; i < numPA; i++) {
                outcomes.PA += 1;
                const randVal = Math.random();
                let cumulativeProb = 0.0;
                let chosenEvent = 'IPO';
                for (const eventType of eventOrder) {
                    const prob = probabilities[eventType] || 0;
                    cumulativeProb += prob;
                    if (randVal < cumulativeProb) {
                        chosenEvent = eventType;
                        break;
                    }
                }
                outcomes[chosenEvent] += 1;
                if (['HR', '2B', '1B'].includes(chosenEvent)) {
                    outcomes.H += 1;
                    outcomes.AB += 1;
                } else if (['K', 'IPO'].includes(chosenEvent)) {
                    outcomes.OUT += 1;
                    outcomes.AB += 1;
                }
            }
            return outcomes;
        }
        
        function calculateSimStats(simResults) {
            const stats = {};
            const ab = simResults.AB || 0;
            const h = simResults.H || 0;
            const bb = simResults.BB || 0;
            const hbp = simResults.HBP || 0;
            const pa = simResults.PA || 0;
            const k = simResults.K || 0;
            stats.BA = ab > 0 ? h / ab : 0;
            stats.OBP = pa > 0 ? (h + bb + hbp) / pa : 0;
            const tb = (simResults['1B'] || 0) * 1 + (simResults['2B'] || 0) * 2 + (simResults.HR || 0) * 4;
            stats.SLG = ab > 0 ? tb / ab : 0;
            stats.OPS = stats.OBP + stats.SLG;
            stats.K_rate = pa > 0 ? k / pa : 0;
            stats.BB_rate = pa > 0 ? bb / pa : 0;
            stats.HR_count = simResults.HR || 0;
            stats.BB_count = bb;
            stats.K_count = k;
            stats.H_count = h;
            stats.AB_count = ab;
            stats.PA_count = pa;
            return stats;
        }
        
        // 修正的 OVR 計算函數（移除硬上限，降低精英門檻）
        function calculateBatterOVR(pow, hit, eye) {
            // 算術平均作為基礎
            const arithmeticMean = (pow + hit + eye) / 3;
            
            // 幾何平均 (反映整體實力，避免短板效應)
            const geometricMean = Math.pow(pow * hit * eye, 1/3);
            
            // 基礎 OVR：算術平均為主，幾何平均為輔
            let baseOVR = arithmeticMean * 0.8 + geometricMean * 0.2;
            
            // === 更敏感的精英球員加成系統 ===
            let eliteBonus = 0;
            
            // 1. 降低精英門檻：從 75 開始溫和加成
            if (arithmeticMean > 75) {
                const earlyEliteFactor = Math.min((arithmeticMean - 75) / 10, 1.0); // 75-85的進度
                eliteBonus += earlyEliteFactor * earlyEliteFactor * 1.5; // 最多+1.5分
            }
            
            // 2. 中段精英加成（85-99區間）
            if (arithmeticMean > 85) {
                const midEliteFactor = Math.min((arithmeticMean - 85) / 14, 1.0); // 85-99的進度
                eliteBonus += midEliteFactor * midEliteFactor * 3.5; // 最多+3.5分
            }
            
            // 3. 超級精英加成（99+區間，對數增長）
            if (arithmeticMean > 99) {
                const superEliteFactor = arithmeticMean - 99;
                // 對數增長，但保留無上限特性
                eliteBonus += Math.log(1 + superEliteFactor) * 3.0;
            }
            
            // 4. 個別屬性突破獎勵（恢復適中強度）
            let breakthroughBonus = 0;
            [pow, hit, eye].forEach(attr => {
                if (attr > 90) { // 降低門檻從95到90
                    breakthroughBonus += (attr - 90) * 0.06;
                }
                if (attr > 105) {
                    breakthroughBonus += (attr - 105) * 0.10;
                }
                if (attr > 120) { // 超人級別
                    breakthroughBonus += (attr - 120) * 0.15;
                }
            });
            eliteBonus += breakthroughBonus;
            
            // 5. 全面優秀獎勵（基於相關係數理論）
            // 當三圍都超過某個門檻時，由於正相關性，實際稀有度更高
            const allAboveThresholds = [
                {threshold: 80, bonus: 0.8},  // 三圍都>80
                {threshold: 85, bonus: 1.2},  // 三圍都>85
                {threshold: 90, bonus: 1.8},  // 三圍都>90
                {threshold: 95, bonus: 2.5},  // 三圍都>95
                {threshold: 100, bonus: 3.5}, // 三圍都>100
                {threshold: 110, bonus: 5.0}  // 三圍都>110
            ];
            
            allAboveThresholds.forEach(({threshold, bonus}) => {
                if (pow > threshold && hit > threshold && eye > threshold) {
                    const excessAvg = (pow + hit + eye) / 3 - threshold;
                    eliteBonus += bonus + excessAvg * 0.1; // 基礎獎勵+超出部分
                }
            });
            
            // 6. 均衡度調整
            const maxAttribute = Math.max(pow, hit, eye);
            const minAttribute = Math.min(pow, hit, eye);
            const balanceRatio = minAttribute / maxAttribute;
            
            // 均衡獎勵（更敏感）
            if (balanceRatio > 0.7 && arithmeticMean > 75) { // 降低門檻
                const balanceBonus = (balanceRatio - 0.7) * (arithmeticMean - 75) * 0.05;
                eliteBonus += balanceBonus;
            }
            
            // 7. 極端專精補償
            const hasExtremeTalent = maxAttribute > 95;
            if (hasExtremeTalent && balanceRatio < 0.6) {
                const specializationBonus = (maxAttribute - 95) * 0.08 * (1 - balanceRatio);
                eliteBonus += specializationBonus;
            }
            
            // 8. 相關性調整（輕微）
            const correlationFactor = 0.75;
            const correlationAdjustment = correlationFactor * eliteBonus * 0.12; // 進一步降低
            eliteBonus -= correlationAdjustment;
            
            // 9. 實戰表現權重（溫和）
            let performanceWeight = 1.0;
            const estimatedOPS = (pow * 0.006 + hit * 0.004 + eye * 0.005) + 0.2;
            
            if (estimatedOPS > 1.200) { // 神級 OPS
                performanceWeight += (estimatedOPS - 1.200) * 1.0;
            } else if (estimatedOPS > 1.000) { // 傳奇級 OPS
                performanceWeight += (estimatedOPS - 1.000) * 0.6;
            } else if (estimatedOPS > 0.900) { // 頂尖 OPS
                performanceWeight += (estimatedOPS - 0.900) * 0.4;
            } else if (estimatedOPS > 0.800) { // 優秀 OPS
                performanceWeight += (estimatedOPS - 0.800) * 0.2;
            }
            
            eliteBonus *= performanceWeight;
            
            // === 移除硬上限，僅保留軟上限壓縮 ===
            
            // 最終 OVR 計算
            let finalOVR = baseOVR + eliteBonus;
            
            // 多層軟上限，逐漸壓縮但不封頂
            if (finalOVR > 140) {
                finalOVR = 140 + (finalOVR - 140) * 0.2; // 140+ 區間大幅壓縮
            } else if (finalOVR > 120) {
                finalOVR = 120 + (finalOVR - 120) * 0.4; // 120-140 區間中度壓縮
            } else if (finalOVR > 110) {
                finalOVR = 110 + (finalOVR - 110) * 0.7; // 110-120 區間輕度壓縮
            }
            
            // 理論上不設上限，但實際上會因為軟上限而很難超過某個值
            finalOVR = Math.max(1, finalOVR);
            
            return {
                ovr: Math.round(finalOVR),
                breakdown: {
                    arithmeticMean: arithmeticMean.toFixed(1),
                    geometricMean: geometricMean.toFixed(1),
                    baseOVR: baseOVR.toFixed(1),
                    eliteBonus: eliteBonus.toFixed(1),
                    balanceRatio: balanceRatio.toFixed(2),
                    performanceWeight: performanceWeight.toFixed(2),
                    estimatedOPS: estimatedOPS.toFixed(3),
                    finalBeforeCap: (baseOVR + eliteBonus).toFixed(1),
                    hasAllAbove80: (pow > 80 && hit > 80 && eye > 80) ? "✓" : "✗",
                    hasAllAbove90: (pow > 90 && hit > 90 && eye > 90) ? "✓" : "✗"
                }
            };
        }
        
        function displayOVRBreakdown(breakdown, targetElement) {
            if (!targetElement) return;
            
            const html = `
                <strong>OVR 計算詳情：</strong><br>
                算術平均：${breakdown.arithmeticMean}<br>
                基礎 OVR：${breakdown.baseOVR}<br>
                精英加成：+${breakdown.eliteBonus} (無硬上限)<br>
                加成前：${breakdown.finalBeforeCap}<br>
                均衡度：${breakdown.balanceRatio}<br>
                表現權重：${breakdown.performanceWeight}x<br>
                預估 OPS：${breakdown.estimatedOPS}<br>
                全面80+：${breakdown.hasAllAbove80}<br>
                全面90+：${breakdown.hasAllAbove90}
            `;
            
            targetElement.innerHTML = html;
        }
        
        function calculateAttributes() {
            const xBA = parseFloat(document.getElementById('xBA').value);
            const xSLG = parseFloat(document.getElementById('xSLG').value);
            const xwOBA = parseFloat(document.getElementById('xwOBA').value);
            
            if (!xBA || !xSLG || !xwOBA) {
                alert('請填入所有數據！');
                return;
            }
            
            if (xBA < 0 || xBA > 1 || xSLG < 0 || xSLG > 4 || xwOBA < 0 || xwOBA > 1) {
                alert('請確保所有數據都在 0-1 之間！');
                return;
            }
            
            const attributes = calculatePlayerGameAttributes(xBA, xSLG, xwOBA);
            const ovrResult = calculateBatterOVR(attributes.POW, attributes.HIT, attributes.EYE);
            
            document.getElementById('powResult').textContent = attributes.POW.toFixed(1);
            document.getElementById('hitResult').textContent = attributes.HIT.toFixed(1);
            document.getElementById('eyeResult').textContent = attributes.EYE.toFixed(1);
            document.getElementById('ovrFromStats').textContent = ovrResult.ovr;
            
            displayOVRBreakdown(ovrResult.breakdown, document.getElementById('ovrBreakdownStats'));
            
            document.getElementById('attributeResults').style.display = 'block';
        }
        
        function calculateStats() {
            const pow = parseFloat(document.getElementById('inputPOW').value);
            const hit = parseFloat(document.getElementById('inputHIT').value);
            const eye = parseFloat(document.getElementById('inputEYE').value);
            const pa = parseInt(document.getElementById('inputPA').value);
            
            if (!pow || !hit || !eye || !pa) {
                alert('請填入所有三圍和打席數！');
                return;
            }
            
            if (pow < 0 || hit < 0 || eye < 0 || pa < 1) {
                alert('請確保所有數值都為正數！');
                return;
            }
            
            if (pow > 500 || hit > 500 || eye > 500) {
                alert('三圍不得超過500！');
                return;
            }
            
            const eventProbs = getPAEventProbabilities(pow, hit, eye);
            
            let totalStats = {BA: 0, OBP: 0, SLG: 0, OPS: 0, K_rate: 0, BB_rate: 0, HR_count: 0};
            for (let i = 0; i < NUM_SIMULATIONS; i++) {
                const seasonResults = simulateSeason(pa, eventProbs);
                const stats = calculateSimStats(seasonResults);
                totalStats.BA += stats.BA;
                totalStats.OBP += stats.OBP;
                totalStats.SLG += stats.SLG;
                totalStats.OPS += stats.OPS;
                totalStats.K_rate += stats.K_rate;
                totalStats.BB_rate += stats.BB_rate;
                totalStats.HR_count += stats.HR_count;
            }
            
            for (let key in totalStats) {
                totalStats[key] /= NUM_SIMULATIONS;
            }
            
            const ovrResult = calculateBatterOVR(pow, hit, eye);
            
            document.getElementById('baResult').textContent = totalStats.BA.toFixed(3);
            document.getElementById('obpResult').textContent = totalStats.OBP.toFixed(3);
            document.getElementById('slgResult').textContent = totalStats.SLG.toFixed(3);
            document.getElementById('opsResult').textContent = totalStats.OPS.toFixed(3);
            document.getElementById('hrResult').textContent = Math.round(totalStats.HR_count);
            document.getElementById('bbRateResult').textContent = (totalStats.BB_rate * 100).toFixed(1) + '%';
            document.getElementById('kRateResult').textContent = (totalStats.K_rate * 100).toFixed(1) + '%';
            document.getElementById('ovrFromAttributes').textContent = ovrResult.ovr;
            
            displayOVRBreakdown(ovrResult.breakdown, document.getElementById('ovrBreakdownAttributes'));
            
            document.getElementById('statsResults').style.display = 'block';
        }
        
        document.addEventListener('DOMContentLoaded', function() {
            console.log('棒球能力值計算器已載入');
            
            // 設置輸入驗證
            ['xBA', 'xSLG', 'xwOBA'].forEach(id => {
                const input = document.getElementById(id);
                input.addEventListener('input', function() {
                    const value = parseFloat(this.value);
                    if (value < 0 || value > 1) {
                        this.style.borderColor = '#ff6b6b';
                    } else {
                        this.style.borderColor = '#4ecdc4';
                    }
                });
            });
            
            ['inputPOW', 'inputHIT', 'inputEYE'].forEach(id => {
                const input = document.getElementById(id);
                input.addEventListener('input', function() {
                    const value = parseFloat(this.value);
                    if (value < 0 || value > 150) {
                        this.style.borderColor = '#ff6b6b';
                    } else {
                        this.style.borderColor = '#4ecdc4';
                    }
                });
            });
            
            const paInput = document.getElementById('inputPA');
            paInput.addEventListener('input', function() {
                const value = parseInt(this.value);
                if (value < 1 || value > 1000) {
                    this.style.borderColor = '#ff6b6b';
                } else {
                    this.style.borderColor = '#4ecdc4';
                }
            });
        });
    </script>
</body>
</html>